# GoGen
`gogen` is a tool for generating terraform codes using input config data in yaml files format. Terraform codes are generated in the `terraform` directory. The inputs (yaml files) config data are supplied in the directory `config_data` by default or can be overriden by user at run time. The config data are used to generate terraform modules to build on aws/azure/gcp. Note that Azure and GCP `providers` codebased has not been created yet. Furthermore, the terraform modules we're creating here are the `config data terraform modules` not the `library` or `re-usable modules`. These are normally provided by open source respositories (`registry.terraform.io`, public Github repos, or your internal private Github repos). If the open source does not have a terraform library module, you should create one first and defined the new `config_data/<your-new-module-yaml-file>` using the `gogen` tool to generate your new terraform module.


# GoDeploy
`godeploy` is a tool for managing deployments using Terraform on AWS/AZURE/GCP. This tool can run interactively or by CI/CD tools.

Note that this is an opinionated terraform framework, where one do not need to manually write config terraform modules. The framework can be used to build the whole environment or single module. Terraform state file management is catered by S3 with dynamo DB locking.

# GoRunner (TODO: Implement)
`gorunner` is an API used in conjunction with `gogen` and `godeploy` 

## Note
Only AWS is being developed at the moment. 

## Project Structure
```
github.com/dieple/godeploy
├── cmd
│   ├── godeploy
│   │   └── godeploy.go
│   └── gogen
│       └── gogen.go
├── config_data
│   ├── config.yaml                 # modify this file to your specifics environments
│   ├── initial.yaml                # this is used to setup initial s3 buckets and dynamodb on the SRE account to hold all TF state files.
│   ├── initial_iam_roles.yaml      # initial role called "terraform" which the SRE account can be used to assume role into destination accounts during terraform build time 
... snippet ...
│   ├── dynamo.yaml                 # the rest of your terraform config modules files live here ...     
│   ├── ecr_repositories.yaml
│   ├── ecs_cluster.yaml
│   ├── elasticache_redis.yaml
│   └── rds_aurora_mysql.yaml
... snippet ...
├── go.mod
├── go.sum
├── internal
│   ├── config
│   │   └── config.go
│   ├── deploy
│   │   ├── files.go
│   │   ├── find_modules.go
│   │   ├── prompts.go
│   │   └── tfrun.go
│   ├── logger
│   │   └── logger.go
│   └── utils
│       └── utils.go
├── Makefile
├── README.md
```

## Generated `terraform` Directory
Below are typical terraform files generated by the gogen CLI:
```
└── terraform
    ├── aws
    │   ├── main
    │   │   ├── containers
    │   │   │   ├── ecr-repositories
    │   │   │   │   ├── data.tf
    │   │   │   │   ├── locals.tf
    │   │   │   │   ├── main.tf
    │   │   │   │   ├── outputs.tf
    │   │   │   │   ├── policy.tf
    │   │   │   │   └── variables.tf
    │   │   │   └── ecs-cluster
    │   │   │       ├── data.tf
    │   │   │       ├── locals.tf
    │   │   │       ├── main.tf
    │   │   │       ├── outputs.tf
    │   │   │       └── variables.tf
    │   │   ├── databases
    │   │   │   ├── dynamo
    │   │   │   │   ├── data.tf
    │   │   │   │   ├── locals.tf
    │   │   │   │   ├── main.tf
    │   │   │   │   ├── outputs.tf
    │   │   │   │   └── variables.tf
    │   │   │   ├── elasticache-redis
    │   │   │   │   ├── data.tf
    │   │   │   │   ├── locals.tf
    │   │   │   │   ├── main.tf
    │   │   │   │   ├── outputs.tf
    │   │   │   │   └── variables.tf
    │   │   │   └── rds-aurora-mysql
    │   │   │       ├── data.tf
    │   │   │       ├── locals.tf
    │   │   │       ├── main.tf
    │   │   │       ├── outputs.tf
    │   │   │       └── variables.tf
    │   │   └── initial
    │   │       ├── initial-iam-roles
    │   │       │   ├── data.tf
    │   │       │   ├── locals.tf
    │   │       │   ├── main.tf
    │   │       │   ├── outputs.tf
    │   │       │   └── variables.tf
    │   │       └── initial-state-config
    │   │           ├── data.tf
    │   │           ├── locals.tf
    │   │           ├── main.tf
    │   │           ├── outputs.tf
    │   │           ├── policy.tf
    │   │           ├── variables.tf
    │   │           └── versions.tf

...  snippet ...
    │   └── variables
    │       ├── _accounts.tf
    │       ├── _envs.tf
    │       └── _providers.tf

...  snippet ...

    └── README.md
```

## Installation
1. Download and install go: https://go.dev/doc/install
2. Clone this repository:
```bash
git clone https://github.com/dieple/godeploy.git
```

## Environment Setup / Configurations
Anything under the directory `config_data` is where you store your environment specific config data to generate the terraform codes. The generated codes will be placed under the `terraform` directory.

* config_data/`config.yaml`
    * A typical `config.yaml` is shown below. This is the place where you defined the make up of your environments. In order to cater for multi accounts with single terraform module (or codebase and using the DRY concept), we use terraform `workspaces` to build/distinguish between environments. The workspaces in this particular case are the fields called `id` under the `envs` section (see yaml file below) All yours AWS accounts (existing and new) should be defined here. By convention we should aim to name the workspace as meaningful and short as possible.
    
    * The `workspace_iam_role` is the `arn` of the role that's used for role switching into the destination AWS account to do the building. For example, if you wanted to build some resourses on the account called `Prod` the `workspace_iam_role` should exist in the prod account and with right permissions to create resourses in the production account. This role is created in each individual account by using the module `terraform/aws/main/initial/initial-iam-roles`. 
    
    * The `share_sre_iam_role` role is used to assume role into the `SRE` account to access centralise resourses such as environment variables and secrets stored in the `Parameter Store`, `Secrets Manager` or docker images in `ECR repositories` and so on.
    
    * The `share_r53_iam_role` role is the role on the master account. This role is route53 purposes. We've decided to use the Master account for centralise domain name registrations. Let's say you want to register a domain named `example.io`. This domain should be registered on the master account. For subsequent sub account that needs to use the domain we can created hosted zones like so `<workspace>.example.io` for example `sre.example.io` in the SRE account or `dev.example.io` in the dev account. The `share_r53_iam_role` is used to switch role during terraform run to update the Master account Route53 name servers (NS records) that points to `sre.example.io` or `dev.example.io` and so on in the sub accounts.

```yaml
envs:
  - id: master                                                          # terraform workspace name
    account_id: "111111111111"                                          # modify to correct AWS account
    account_name: "MASTER Account"                                      # Description used in the `godeploy` for interactive runs
    workspace_iam_role: "arn:aws:iam::111111111111:role/terraform"      # for SRE account to switch role during terraform build
    share_sre_iam_role: "arn:aws:iam::222222222222:role/terraform"      # Assume role for parameter store, secrets manager resourse
    share_r53_iam_role: "arn:aws:iam::111111111111:role/terraform"      # assume role to Master account for Route53 hosted zone creation on the sub accounts
    region: "eu-west-2"                                                 # the region where this TF workspace belongs to (different from one workspace to another)
    bucket_region: "eu-west-2"                                          # SRE's account bucket regions (fixed and should never changed)
    bucket: "tf-state-bucket"                                           # Name of the state file S3 bucket that lives on the SRE account (modify to match your env)
    dynamodb: "tf-state-lock-dynamodb"                                  # Name of the dynamo db on the SRE account (modify to match your env)

  - id: sre
    account_id: "222222222222"
    account_name: "SRE/DEVOPS Terraform Building Account"
    workspace_iam_role: "arn:aws:iam::222222222222:role/terraform"
    share_sre_iam_role: "arn:aws:iam::222222222222:role/terraform"
    share_r53_iam_role: "arn:aws:iam::111111111111:role/terraform"
    region: "eu-west-2"
    bucket_region: "eu-west-2"
    bucket: "tf-state-bucket"
    dynamodb: "tf-state-lock-dynamodb"

  - id: dev
    account_id: "333333333333"
    account_name: "DEVELPMENT ACCOUNT"
    workspace_iam_role: "arn:aws:iam::333333333333:role/terraform"
    share_sre_iam_role: "arn:aws:iam::222222222222:role/terraform"
    share_r53_iam_role: "arn:aws:iam::111111111111:role/terraform"
    region: "eu-west-2"
    bucket_region: "eu-west-2"
    bucket: "tf-state-bucket"
    dynamodb: "tf-state-lock-dynamodb"

...  snippet ...
  - id: prod
    account_id: "666666666666"
    account_name: "PRODUCTION ACCOUNT"
    workspace_iam_role: "arn:aws:iam::666666666666:role/terraform"
    share_sre_iam_role: "arn:aws:iam::222222222222:role/terraform"
    share_r53_iam_role: "arn:aws:iam::111111111111:role/terraform"
    region: "eu-west-2"
    bucket_region: "eu-west-2"
    bucket: "tf-state-bucket"
    dynamodb: "tf-state-lock-dynamodb"

... snippet ...

directory:                                                      # Root directory of the generated terraform files e.g. "terraform/aws/main"
  root_gen_dir: terraform
  cloud_provider: aws
  tf_main_dir: main

default_tags:
  Customer: infra                                               # global 'default tags' for all resources edit add/remove fields to match your requirements
  Product: infra
  CostCentre: infra
  ManagedBy: terraform

module_dir:
  initial.yaml: initial/initial-state-config                    # LHS: Terraform module (content of file defined the makeup). RHS subdirectories where it should be created
  initial_iam_roles.yaml: initial/initial-iam-roles
  ecr_repositories.yaml: containers/ecr-repositories
  ecs_cluster.yaml: containers/ecs-cluster
  dynamo.yaml: databases/dynamo
  elasticache_redis.yaml: databases/elasticache-redis
  rds_aurora_mysql.yaml: databases/rds-aurora-mysql
  rds_aurora_postgres.yaml: databases/rds-aurora-postgres
  rds_mysql.yaml: database/rds-mysql
  rpm_cloudfront.yaml: distributions/rpm-cloudfront
  api_sg.yaml: firewall/api-sg
  aqse_capture_sg.yaml: firewall/aqse-capture-sg
  aqse_control_sg.yaml: firewall/aqse-control-sg
  aqse_core_sg.yaml: firewall/aqse-core-sg
  aqse_web_db_sg.yaml: firewall/aqse-webdb-sg
  bastion_sg.yaml: firewall/bastion-sg
  redis_sg.yaml: firewall/redis-sg
  vpc.yaml: networkings/vpc
  ...

```

In the `module_dir` section we defined the terraform modules that we're going to create. On the LHS is the name of the input config data yaml files (e.g `ecr_repositories.yaml`, `elasticache_redis.yaml`, and so on) and its corresponding directories will be created on the RHS, in this particular case its `<root_gen_dir>/cloud_provider><main><and-individual-dir-under-module_dir_section>` (e.g. for `ecr_repositories.yaml` file the output terraform files will be created under the directory: `terraform/aws/main/containers/ecr-repositories` and for `elasticache_redis.yaml` it's `terraform/aws/main/databases/elasticache-redis`) and so on. This `config.yaml` is important take your time to understand and modify according to your company's environments. The directory structures is important for the `godeploy` tool to run the terraform actions against a particular providers (in this case AWS is implemented first)


* config_data/`initial.yaml`: Initial configuration file for Terraform deployment. in otherwords, the S3 and state file management created on the SRE (or build account)
* config_data/`<module_name_with_underscore>.yaml`: individual terraform modules/name you wanted the `gogen` to generate.

### Some examples of input yanl files
```yaml

# content of config_data/ecr_repositories.yaml

locals:                                                                             # local vaiables
  allowed_account_ids: "${[for name, id in local.org_accounts : id if name != \"share\"]}"
  write_iam_arns: "${compact(concat(formatlist(\"arn:aws:iam::%s:root\", local.allowed_account_ids), tolist(\"arn:aws:iam::local.org_accounts[\"sre\"]:user/terraform\")))}"
  read_iam_arns: "${tolist([\"arn:aws:iam::local.org_accounts[\"tc1\"]:role/tc1-role\", \"arn:aws:iam::local.org_accounts[\"tc2\"]:role/tc2-role\"])}"
  allow_push: true
  image_tag_mutability: "MUTABLE"
  scan_on_push: true
  max_image_count: 30
  registry_policy: "${data.aws_iam_policy_document.default.json}"
  repository_names:
    - "cms"
    - "infra-ci"
    - "cms-db-migrations"
    - "elements-grafana"
    - "elements-exchange-api"
    - "aqx-docker-boto3"
    - "update-indices"
    - "search-nginx-proxy"
    - "bitbucket-centos-base"
    - "bitbucket-rocky-base"


policy:                                                                             # data policy for this module defined here
  statement:
    - sid: "ECRReadOnlyPolicy"
      principals:
        - type: "AWS"
          identifiers:
            - "${local.read_iam_arns}"
      actions:
        - "ecr:BatchCheckLayerAvailability"
        - "ecr:GetDownloadUrlForLayer"
        - "ecr:GetRepositoryPolicy"
        - "ecr:DescribeRepositories"
        - "ecr:ListImages"
        - "ecr:DescribeImages"
        - "ecr:BatchGetImage"
      resources:
        - "*"
    - sid: "ECRReadWritePolicy"
      principals:
        - type: "AWS"
          identifiers:
            - "${local.write_iam_arns}"
      actions:
        - "ecr:BatchCheckLayerAvailability"
        - "ecr:BatchGetImage"
        - "ecr:CompleteLayerUpload"
        - "ecr:DescribeImages"
        - "ecr:DescribeRepositories"
        - "ecr:GetAuthorizationToken"
        - "ecr:GetDownloadUrlForLayer"
        - "ecr:GetRepositoryPolicy"
        - "ecr:InitiateLayerUpload"
        - "ecr:ListImages"
        - "ecr:PutImage"
        - "ecr:UploadLayerPart"
        - "imagebuilder:GetComponent"
        - "imagebuilder:GetContainerRecipe"
      resources:
        - "*"

module:
  - module_name: "ecr_repos"                                                        # name of terraform module
    source: "git::https://github.com/dieple/tfmodules.git//aws/ecr-repositories"    # source with git tag if neccessary
    allowed_account_ids: "${local.allowed_account_ids}"                             # the rest are parameters input for this terraform module
    repository_names: "${local.repository_names}"
    allow_push: "${local.allow_push}"
    image_tag_mutability: "${local.image_tag_mutability}"
    scan_on_push: "${local.scan_on_push}"
    max_image_count: "${local.max_image_count}"
    registry_policy: "${local.registry_policy}"


outputs:                                                                            # terraform outputs defined here
  registry_ids:
    value: module.ecr_repos.registry_ids
  repository_urls:
    value: module.ecr_repos.registry_urls
  repository_names:
    value: module.ecr_repos.repository_names

variables:                                                                          # variables defined here
  - name: "environment"
    type: "string"
    default: "${terraform.workspace}"```
```

A module for an input yaml file, at a minimum should have `module` section defined. A typical input yaml file should normally have sections such as `locals`, `outputs`, `data` and `variables` or `policy` defined.


## Usage
* After setting the config data for your environment then it's time generate/create modules. We use the Make file for this purpose.

```bash
make gen
```

## Account structures
This section documents how the account is structures, created and build:

```
Master Account
│
└── SRE Account
    ├── Development Account
    ├── Testing Account
    └── Production Account Group
        ├── Finance Account Group
        │   ├── Billing Account
        │   └── Compliance Account
        │
        ├── Security Accounts
        │   ├── Identity and Access Management Account
        │   └── Security Operations Account
        │
        ├── Data Engineering Account Group
        │   ├── Data Processing Account
        │   └── Data Warehousing Account
        │
        └── Business Applications Account
            ├── CRM Account
            └── ERP Account

```
### Master account
Responsible for organisational consolidated billings, create/invite other aws account into the organisation. Register domain names. Normally, the Master account is used to setup SSO and created sub accounts within your organisation.

### SRE account
This framework assumed that there must be an `SRE (or terraform build) account` created for the purpose of `godeploy` CLI tool to run and create AWS resources - The state files live in this account along with the dynamodb (see below step `Setup State file management...` for more details). Use the Master account (such as AWS Control Tower, etc) to create the SRE account and all other accounts for your environment. Remember to update the `config.yaml` as you go along. 


## Setup State file management using the initial module
* To initially setup the S3 bucket and dynamodb for state file locking run the following:

```bash
    make gen
    cd terraform/aws/main/initial/initial-state-config
    terraform init
    terraform plan
    terraform apply
```

## Setup initial role for subsequent terraform builds
* To create a role called `terraform` which is used subsequently to create all AWS resources.

After the new account has been created (for example, in the AWS Control Tower). Using the root `login email address` to log in (new account) to AWS web comsole  and modify the
iam role `OrganisationAccountAccessRole` Trust Relationships policy to below:
``` hcl
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "AWS": [
                    "arn:aws:iam::<master-account-id>:root", # master a/c
                    "arn:aws:iam::<sre-account-id>:root", # sre a/c
                    "arn:aws:iam::<sre-account-id>:user/terraform"
                ]
            },
            "Action": "sts:AssumeRole"
        }
    ]
}
```

Remmeber to also modify the file `_envs.tf` for the SRE account to below:
```terraform
workspace_iam_role  = "arn:aws:iam::202217845864:role/OrganizationAccountAccessRole"
```

Assume role to SRE user/terraform and this run module interactively to create the initial `terraform` IAM.

Basically, this gives the IAM user `user/terraform` on the SRE account to be able to assume the `OrganisationAccountAccessRole` role (this role always created initially by AWS when new AWS account were created) to create the new role called `role/terraform` on the new account. This `role/terraform` should have all privilages to create AWS resources (subsequently) when terraform is run by the `godeploy` tool.

* Note that the above steps should be performed for all new AWS accounts




# Using godeploy Tool:
Initially generate/create terraform modules and then using the `godeploy` to run the terraform modules

```bash
make gen
make deploy
```
Then follow the interactive menu driven to pick and choose modules to deploy on any AWS accounts

![Select providers](images/01_select_providers.png)
The LHS display a list providers to choose. Note that only AWS is working at the moment. The RHS are the `preview` windows. It explain in further what the selected option means.  Select AWS then press enter.

![Choose workspace](images/02_choose_workspace.png)

Scroll up/down to choose the workspace (or environment or accountID) and press `Enter`

![Choose module](images/03_choose_tf_module.png)

Scroll up/down to choose module(s) to build. Note that you can multi-select modules to build at the same time. then press `enter` key.


![Choose tf action](images/04_choose_tf_action.png)

Scroll up/down to choose the terraform action to build, then press `enter` key.

That's it wait for terraform to finish it run and check the results on AWS web console.




# Contributing
Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.

# License
This project is licensed under the MIT License.
